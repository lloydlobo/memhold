/*
**
** memhold - Simple timeouts for processes that hog memory
**
**
*/

// file: main.c

/**************************************************************************************************
 *
 *
 * memhold 0.1
 *
 * TODOS: ~
 *   - Use atomic signal/process calls
 *     Do not make more calls or write/print to stdout while file pointer is open
 *     One doesn't know what other process(s) is calling the one we are accessing
 *
 *   - Do not use conditional macros inside function calls that make it unclear what the control flow would be. Instead extract that procedure(s) into its own
 *     function and add #if #endif macro to that. (add a NoOp function for #else case)
 *
 * PROFILE: ~
 *  20240704144247UTC
 *      ==48754== Command: ./memhold 2007
 *      [ INFO ]  took 8.00s
 *      ==48754== HEAP SUMMARY:
 *      ==48754==     in use at exit: 0 bytes in 0 blocks
 *      ==48754==   total heap usage: 9 allocs, 9 frees, 7,008 bytes allocated
 *      ==48754== All heap blocks were freed -- no leaks are possible
 *      ==48754== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
 *
 *      ==46954== Command: ./memhold 2007
 *      [ INFO ]  took 8.00s
 *      ==46954== I refs:        285,880
 *
 *
 *************************************************************************************************/

#include "memhold.h" // Declares module functions


#include <assert.h> // Required for: assert()
#include <signal.h>
#include <stdio.h>  // Required for: printf(), fprintf(), sprintf(), stderr, stdout, popen() [with compiler option `-pthread`]
#include <stdlib.h> // Required for: atoi(), exit()
#include <string.h> // Required for: strcmp(), NULL
#include <sys/wait.h>
#include <time.h>   // Required for: clock(), [time() ~ not used]
#include <unistd.h> // Required for: fork(), getpid(), sleep(),... [UNIX only lib]

/* 1.14. /proc

Linux Filesystem Hierarchy:
Chapter 1. Linux Filesystem Hierarchy
See https://tldp.org/LDP/Linux-Filesystem-Hierarchy/html/proc.html

The purpose and contents of each of these files is explained below:

/proc/PID/cmdline   Command line arguments.
/proc/PID/cpu       Current and last cpu in which it was executed.
/proc/PID/cwd       Link to the current working directory.
/proc/PID/environ   Values of environment variables.
/proc/PID/exe       Link to the executable of this process.
/proc/PID/fd        Directory, which contains all file descriptors.
/proc/PID/maps      Memory maps to executables and library files.
/proc/PID/mem       Memory held by this process.
/proc/PID/root      Link to the root directory of this process.
/proc/PID/stat      Process status.
/proc/PID/statm     Process memory status information.
/proc/PID/status    Process status in human readable form.

Should you wish to know more, the man page for proc describes each of the files
associated with a running process ID in far greater detail.
Even though files appear to be of size 0, examining their contents reveals
otherwise:
# cat status
...

Details of this process can be obtained by looking at the associated files in
the directory for this process, /proc/460. You might wonder how you can see
details of a process that has a file size of 0. It makes more sense if you think
of it as a window into the kernel. The file doesn't actually contain any data;
it just acts as a pointer to where the actual process information resides.
...

*/

// TRACING: ~
//
// 20240709063816UTC
//  ✦ ❯ strace -p $(pgrep waybar)
//  strace: Process 2020 attached
//  restart_syscall(<... resuming interrupted read ...>) = 1
//  read(13, "\30$_\2\0\0\0\0`\356W\2\0\0\0\0", 16) = 16
//  poll([{fd=3, events=POLLIN}, {fd=5, events=POLLIN}, {fd=11, events=POLLIN}, {fd=13, events=POLLIN}], 4, -1) = 1 ([{fd=13, revents=POLLIN}])
//  read(13, "\30$_\2\0\0\0\0`\356W\2\0\0\0\0", 16) = 16
//  poll([{fd=3, events=POLLIN}, {fd=5, events=POLLIN}, {fd=11, events=POLLIN}, {fd=13, events=POLLIN}], 4, -1) = 1 ([{fd=13, revents=POLLIN}])
//  read(13, "\30$_\2\0\0\0\0`\356W\2\0\0\0\0", 16) = 16
//  poll([{fd=3, events=POLLIN}, {fd=5, events=POLLIN}, {fd=11, events=POLLIN}, {fd=13, events=POLLIN}], 4, -1) = 1 ([{fd=13, revents=POLLIN}])
//  read(13, "\30$_\2\0\0\0\0`\356W\2\0\0\0\0", 16) = 16
//  poll([{fd=3, events=POLLIN}, {fd=5, events=POLLIN}, {fd=11, events=POLLIN}, {fd=13, events=POLLIN}], 4, -1^Cstrace: Process 2020 detached
//   <detached ...>
//

//-----------------------------------------------------------------------------
// Debug Flags (set in build step)
//-----------------------------------------------------------------------------

// Debugging: ~ + MEMHOLD_SLOW = 0 --> fast code + MEMHOLD_SLOW = 1 --> slow code: See in "./Makefile": ~ + DFLAGS = -DMEMHOLD_SLOW=0
#if defined(MEMHOLD_PROFILE)
        #define MEMHOLD_PROFILE = 0
#endif

// Debugging: ~ + MEMHOLD_SLOW = 0 --> fast code + MEMHOLD_SLOW = 1 --> slow code: See in "./Makefile": ~ + DFLAGS = -DMEMHOLD_SLOW=0
#if defined(MEMHOLD_SLOW)
        #define MEMHOLD_SLOW = 0
#endif

// For when we want to enjoy dabbling with xy problems, code golfing, busy work, and procrastination.
#if defined(MEMHOLD_YAGNI)
        #define MEMHOLD_YAGNI = 0
#endif


//-----------------------------------------------------------------------------
// Macros and Defines
//-----------------------------------------------------------------------------

// clang-format off
#define COLOR_INFO    CLITERAL(Color) { 102, 191, 255, 255 }   // Sky Blue
#define COLOR_WARN    CLITERAL(Color) { 255, 161, 0, 255 }     // Orange
#define COLOR_ERROR   CLITERAL(Color) { 230, 41, 55, 255 }     // Red
#define COLOR_SUCCESS CLITERAL(Color) { 0, 228, 48, 255 }      // Green
// clang-format on


//-----------------------------------------------------------------------------
// Some constants
//-----------------------------------------------------------------------------

#if MEMHOLD_PROFILE
static const int MAX_HOT_LOOP_COUNT = (1 << 2); //> `256 (0x100)` (1 << 8) 2s refresh cycle per loop
#else
static const int MAX_HOT_LOOP_COUNT = (1 << 8); //> `256 (0x100)` (1 << 8) 2s refresh cycle per loop
#endif /* if MEMHOLD_PROFILE */

// Limit fopen for file at path: `char path[256]; snprintf(path, sizeof(path), "/proc/%d/status", pid);`
static const int MAX_RETRIES_FILE_NOT_FOUND = (1 << 3); //> `8 (0x100)` (1 << 3)


//-----------------------------------------------------------------------------
// DATA STRUCTURESSSSS
//-----------------------------------------------------------------------------

typedef struct Memhold {
        bool        flagLog;
        bool        flagVerbose;
        const char *apiID;
        char       *apiVersion;
        float       refreshSeconds;
        float       cpuThreshold;
        size_t      memThreshold;
        pid_t       userProcessPID;
        pid_t       memholdMainProcessPID;

} Memhold;

//-----------------------------------------------------------------------------
// Global variables
//-----------------------------------------------------------------------------
// TODO: All declared global variables, must be initialized. Even if it is 0 again.

Memhold memhold = {0};

bool  gVerbose; //@Temp
pid_t gProcPID;

static int cntrFopenRetries = 0;

//-----------------------------------------------------------------------------
// FUNCTIONSSSS
//-----------------------------------------------------------------------------

int           Init(void);
MHAPI Memhold InitMemhold(void);

MHAPI Memhold InitMemhold(void)
{
        return (Memhold){
            .flagLog               = true,     // TODO(Lloyd): Override via CLI args
            .flagVerbose           = gVerbose, // TODO(Lloyd): Override via CLI args
            .apiID                 = MEMHOLD_ID,
            .apiVersion            = MEMHOLD_VERSION,
            .refreshSeconds        = 2.0f,
            .cpuThreshold          = 50.0f,
            .memThreshold          = MH_MEMORY_THRESHOLD, //>10240kb Max: 500000kb
            .userProcessPID        = gProcPID,
            .memholdMainProcessPID = 0,
        };
}

int Init(void)
{
        int status                    = -1; // SUCCESS
        cntrFopenRetries              = 0;
        memhold                       = InitMemhold();
        memhold.memholdMainProcessPID = getpid();
        status                        = 0;
        return status;
};

//-----------------------------------------------------------------------------
// Module specific function declarations
//-----------------------------------------------------------------------------

int RunMain(void);

MHAPI long GetCpuUsage(pid_t pid);
MHAPI long GetMemUsage(pid_t pid);
MHAPI long GetSystemUptimeSec(pid_t pid);

MHAPI void LogProcLimits(pid_t pid);
MHAPI void NoOp(void); // Placeholder function that does nothing.
#if MEMHOLD_YAGNI
MHAPI void PanicUnimplemented(void);
#endif /* if MEMHOLD_YAGNI */

//-----------------------------------------------------------------------------
// Module specific function implementations
//-----------------------------------------------------------------------------

MHAPI void NoOp(void) {}

// See also: ~
//   - snprintf(path, sizeof(path), "/proc/%d/status", pid);
//     /proc/[pid]/status:
//       While primarily used for memory information, it does contain some CPU-related fields:
//
//       Threads: Number of threads in the process
//       voluntary_ctxt_switches and nonvoluntary_ctxt_switches: Context switch counts
//
MHAPI void LogProcLimits(pid_t pid)
{
        long status = -1;

        // /proc
        // NOTE: The file doesn't actually contain any data; it just acts as a
        // pointer to where the actual process information resides.
        // See https://tldp.org/LDP/Linux-Filesystem-Hierarchy/html/proc.html
        char path[256];
        snprintf(path, sizeof(path), "/proc/%d/limits", pid); // Choices: cpuset
        // fprintf(stdout, "[ INFO ]  PID: %d  %s\n", pid, path); //> path = /proc/2014/cpuset

        // The file doesn't actually contain any data; it just acts as a pointer to
        // where the actual process information resides.
        FILE *fp = fopen(path, "r"); //> stream or NULL
        if (!fp) {
                fprintf(stderr, "[ ERR! ]  failed to open status file. file: %p\n", fp);
                status = -1;
                goto ioError;
        }

        { // TODO: Return buffer or pass pointer to buffer to be read to.
                char buffer[1024];
        }

        char line[356];
        int  lineCount = 0;
        while (fgets(line, sizeof(line), fp)) {
                if (memhold.flagVerbose) {
                        lineCount += 1;
                        // FIXME: Print after this function scope ends
                        fprintf(stdout, "[ INFO ]  PID: %d  \t| %2d ~ %s", pid, lineCount, line);
                }
        }

        status = fclose(fp);
        if ((status != 0)) {
                perror("[ !ERR ]  failed to close status file"); // WON'T THIS ABORT/PANIC?
                goto ioError;
        }

        return;

ioError:
        return;
}

/*
 * $ cat /proc/uptime
 * 6644.50 23980.38
 * $ tr . ' ' </proc/uptime | awk '{print $1}'
 * 6667
 */
MHAPI long GetSystemUptimeSec(pid_t pid)
{
        long status = -1;
        long result = -1;

        FILE *fp = fopen("/proc/uptime", "r");
        if (!fp) {
                fprintf(stderr, "[ ERR! ]  failed to open file. file: %p\n", fp);
                status = -1;
                goto ioError; // Bail out when file pointer fails to open
        }

        char line[356];
        int  lineCount    = 0;
        long tmpfieldNext = -1;
        fscanf(fp, "%lu %lu", &result, &tmpfieldNext);

        if (fclose(fp) != 0) {
                fprintf(stderr, "[ ERR! ]  failed to close file. file: %p\n", fp);
                status = -1;
                goto ioError; // Bail out when file pointer fails to close
        }

        return result;

ioError:
        return status;
}

// /proc/[pid]/stat:
// This file contains more detailed CPU usage data. The relevant fields are: ~
//   - utime: User mode CPU time
//   - stime: Kernel mode CPU time
//
// Note: ~
//   - For processes using popen use: ~ "ps -p %d -o %%cpu --no-headers"
MHAPI long GetCpuUsage(pid_t pid)
{
        long status = -1;
        char path[256];
        snprintf(path, sizeof(path), "/proc/%d/stat", pid); // "/proc/%d/stat" is

        // The file doesn't actually contain any data; it just acts as a pointer to
        // where the actual process information resides.
        FILE *fp = fopen(path, "r"); //> stream or NULL
        if (!fp) {
                fprintf(stderr, "[ ERR! ]  failed to open status file. file: %p\n", fp);
                status = -1;
                goto ioError; // Bail out
        }

        const long             CLOCK_TICKS      = sysconf(_SC_CLK_TCK); // Repeated again. it's okay ^_^
        long                   cpuUsage         = -1;                   // Result
        unsigned long long int processUtime     = 0;
        unsigned long long int processStime     = 0;
        long long              processStarttime = 0;

        char line[356];
        int  lineCount = 0;

        // Split fields in output of /proc/<pid>/stat that are presented as a series
        // of numbers and values separated by spaces.
        //
        // See also https://github.com/htop-dev/htop/blob/db73229bddc6efd26875213f7927b156feb5a937/linux/LinuxProcessTable.c#L276
        //----------------------------------------------------------------------------------
        const int MAX_TOKENS_CONSUMED_COUNT = 30; // Prevent infinite loops in inner while loop

        while (fgets(line, sizeof(line), fp)) {
                char *token              = strtok(line, " "); // Divide S into tokens separated by characters in DELIM.
                int   tokenConsumedCount = 1;

                while (token != NULL) {
                        if (tokenConsumedCount >= MAX_TOKENS_CONSUMED_COUNT)
                                break;

                        /* (14) utime  -  %lu */
                        if (tokenConsumedCount == PROCESS_STAT_UTIME_INDEX)
                                processUtime = strtoull(token, NULL, 10);

                        /* (15) stime  -  %lu */
                        if (tokenConsumedCount == PROCESS_STAT_STIME_INDEX)
                                processStime = strtoull(token, NULL, 10);

                        /* (22) starttime  -  %llu */
                        // TODO(Lloyd): Adjust for boottime + adjustTime(lhost, ...)  / 100; See
                        // https://github.com/htop-dev/htop/blob/db73229bddc6efd26875213f7927b156feb5a937/linux/LinuxProcessTable.c#L381
                        if (tokenConsumedCount == PROCESS_STAT_STARTTIME_INDEX) {
                                if (processStarttime == 0)
                                        processStarttime = (strtoll(token, NULL, 10) / CLOCK_TICKS);
                        }

                        token = strtok(NULL, " "); // Consume token
                        tokenConsumedCount += 1;
                }
        }

        if (processUtime && processStime) // getconf
                cpuUsage = (processUtime + processStime);
        assert((cpuUsage != -1) && "expected valid cpu usage while reading /proc/<pid>/stat");
        //----------------------------------------------------------------------------------
        status = fclose(fp); // Cleanup
        if ((status != 0)) {
                perror("[ !ERR ]  failed to close status file");
                goto ioError; // Bail out when close error
        }

        return cpuUsage;

ioError:
        return status;
};

// For processes using popen use: ~ "ps -p %d -o rss --no-headers"
MHAPI long GetMemUsage(pid_t pid)
{
        long status = -1;

        char path[256];
        snprintf(path, sizeof(path), "/proc/%d/status", pid); // Choices: status, mem

        // The file doesn't actually contain any data; it just acts as a pointer to
        // where the actual process information resides.
        FILE *fp = fopen(path, "r"); //> stream or NULL
        if (!fp) {                   // [ ERR! ]  failed to open status file. file: (nil) zsh: segmentation fault (core dumped)  ./memhold $(pgrep clang)
                fprintf(stderr, "[ ERR! ]  failed to open status file. file: %p\n", fp);
                status = -1;
                goto ioError; // Bail out
        }

        char line[356];
        long memoryUsage = -1;

        /*
         * VmRSS stands for Virtual Memory Resident Set Size.
         * VmRSS shows the amount of physical memory (RAM) that a process is
         * currently using. This includes:
         *
         *  - The process's code
         *  - Its data
         *  - Shared libraries that are currently loaded into RAM
         */
        while (fgets(line, sizeof(line), fp)) {
                if (strncmp(line, "VmRSS:", 6) == 0) {
                        sscanf(line + 6, "%ld", &memoryUsage);
                        status = 0; // Success
                        break;
                }
        }

        status = fclose(fp); // Cleanup
        if (status != 0) {
                perror("[ ERR! ]  failed to close status file");
                goto ioError;
        }

        return memoryUsage;

ioError:
        return status;
};


#if MEMHOLD_YAGNI
MHAPI void PanicUnimplemented(void) { UNIMPLEMENTED; }
#endif /* if MEMHOLD_YAGNI */

#if MEMHOLD_SLOW
void LogUserProcessNameSlow(char cmdGetProcName[256])
{
        const int CMD_MAX = 1035;
        int       pstatus;
        FILE     *pipefp;
        char      cmd[CMD_MAX];

        pipefp = popen(cmdGetProcName, "r");
        if (pipefp == NULL) {
                perror("[ ERR! ]  failed to execute popen for getting process name via its PID");
                exit(1);
        }

        int cntr = 0;
        while (fgets(cmd, CMD_MAX, pipefp) != NULL) {
                cntr++;
                fprintf(stdout, "[  OK  ] [%d]: %s", cntr, cmd);
        }

        pstatus = pclose(pipefp);
        if (pstatus == -1)
                perror("[ ERR! ] pclose"); // todo

        #if MEMHOLD_SLOW // TODO: use macros (From examples in popen() are marvelous articles?)
        #else
        fprintf(stdout, "[ INFO ] pclose returned status for: %s\n", cmdGetProcName);
        #endif /* if MEMHOLD_SLOW */
}
#else
void             LogUserProcessNameSlow(char cmdGetProcName[256]) {}
#endif /* if MEMHOLD_SLOW */


//-----------------------------------------------------------------------------
// IT'S SHOWTIME                                                       ^_^
//-----------------------------------------------------------------------------
int RunMain(void)
{
        int status = 0; // EXIT_SUCCESS

        // Log module information to stdout
        //----------------------------------------------------------------------------------
        if (memhold.flagVerbose) {
                fprintf(stdout, "[  OK  ]  <PID> %d\n", memhold.userProcessPID);
                LogProcLimits(memhold.userProcessPID);
        }
        if (memhold.flagLog) {
                // Log user stats
                fprintf(stdout, "[ INFO ]  [ user ]\n");
                fprintf(stdout, "[ INFO ]  PID: %d\n", memhold.userProcessPID);
                // Opts: constants like
                fprintf(stdout, "[ INFO ]  Threshold CPU: %f\n", memhold.cpuThreshold);
                fprintf(stdout, "[ INFO ]  Threshold MEM: %zu\n", memhold.memThreshold);
                // Opts: loop stats
                fprintf(stdout, "[ INFO ]  Refresh: %.2fs (%s)\n", memhold.refreshSeconds, memhold.apiID);

                // Log memhold stats
                fprintf(stdout, "[ INFO ]  [ %s ]\n", memhold.apiID);
                fprintf(stdout, "[ INFO ]  PID: %d\n", memhold.memholdMainProcessPID);
                // Memhold: stats
                fprintf(stdout, "[ INFO ]  Version: %d.%d.%d\n", MEMHOLD_VERSION_MAJOR, MEMHOLD_VERSION_MINOR, MEMHOLD_VERSION_PATCH);
        }
        //----------------------------------------------------------------------------------

        // Prepare main loop
        //----------------------------------------------------------------------------------
        if (memhold.flagVerbose)
                fprintf(stdout, "\n[ INFO ]  <<< Stage 2: Monitor processes >>>\n\n");

        char   cmdCPU[256];
        char   cmdMEM[256];
        size_t cpuUsage[64];
        size_t memUsage[64];
        int    cpuUsageCounter   = 0;
        int    memUsageCounter   = 0;
        size_t cpuUsageThisFrame = 0;
        size_t memUsageThisFrame = 0;
        //----------------------------------------------------------------------------------

#if MEMHOLD_SLOW
        const size_t CMD_SIZE = 64;
        char         cmdPsName[CMD_SIZE];
        int          accumBytes = snprintf(cmdPsName, sizeof(cmdPsName), "ps aux | grep %d", memhold.userProcessPID);
        assert(accumBytes <= CMD_SIZE); //> 18 >= 64
        fprintf(stdout, "[ DEBG ]  executing system command: %s\n", cmdPsName);
        if (system(cmdPsName) != 0) { // Log process Name via system call
                perror("[ ERR! ]  failed to execute command. system call returned");
                exit(1);
        };
        LogUserProcessNameSlow(cmdPsName);

#endif /* if MEMHOLD_SLOW */

        // Run main loop
        //----------------------------------------------------------------------------------
        const long         CLOCK_TICKS         = sysconf(_SC_CLK_TCK); // $ getconf CLK_TCK #> 100 # 100 clock ticks in a second.
        const unsigned int CPU_WAIT_ONE_SECOND = 1;


        unsigned long long cpuTime1, cpuTime2;

        double cpuPercentThisFrame = 0;
        int    loopCounter         = 0;

        while (1) {

                /*      <<<<<<<<<<< Remove this after prototyping >>>>>>>>>>       */
#if 1
                if (loopCounter >= MAX_HOT_LOOP_COUNT) {
                        fprintf(stdout, "%5ld [ WARN ]  *break* main loop on iteration: %d\n", clock(), loopCounter);
                        break;
                };
                loopCounter += 1;
#endif

                /*
                 * Pause this frame (2s *refresh* per frame by default.)
                 *----------------------------------------------------------------------------------
                 * We use sysconf(_SC_CLK_TCK) to get the number of clock ticks
                 * per second, which allows us to convert from clock ticks to seconds.
                 *
                 * Multiply by 1.0 to avoid precision loss while dividing in next instruction
                 */
                memUsageThisFrame = GetMemUsage(memhold.userProcessPID);
                cpuTime1          = GetCpuUsage(memhold.userProcessPID);
                sleep(CPU_WAIT_ONE_SECOND);
                cpuTime2                        = GetCpuUsage(memhold.userProcessPID);
                unsigned long long timeDiff     = (cpuTime2 - cpuTime1);
                long               systemUptime = GetSystemUptimeSec(memhold.userProcessPID); // @Unused
                cpuPercentThisFrame             = (1.0 * timeDiff) / CLOCK_TICKS;
                if ((CPU_WAIT_ONE_SECOND < memhold.refreshSeconds)) // Ensure the loop waited for total `memhold.refreshSeconds` seconds
                        sleep((memhold.refreshSeconds - CPU_WAIT_ONE_SECOND));
                //----------------------------------------------------------------------------------

                if (memhold.flagVerbose) { // fprintf(stdout, "\r[ INFO ]  PID: %d  CPU: %3.6f%%  \t%ld\n", memhold.userProcessPID, cpuPercent, clock());
                        fprintf(stdout, "\r%5ld  [ INFO ]  PID: %d  CPU: %3.4f%%  MEM: %6zuK", clock(), memhold.userProcessPID, cpuPercentThisFrame,
                                memUsageThisFrame);
                        fflush(stdout);
                }
        } // end while (1)
        //----------------------------------------------------------------------------------

        // Unload program
        //----------------------------------------------------------------------------------
        // NOTE(Lloyd): Unload more data or free memory here... (e.g. ML_FREE(...))
        if (memhold.flagVerbose) {
                fprintf(stdout, "\n[ INFO ]  <<< Stage 3: Cleanup and Exit >>>\n\n");
                fprintf(stdout, "[ INFO ]  took %.2fs\n", loopCounter * memhold.refreshSeconds);
        }
        //----------------------------------------------------------------------------------

        return status;
};

// Main entry point of the program.
int main(int argc, char *argv[])
{
        if (argc < 2) {
                fprintf(stderr, "Usage: %s <PID>\n", argv[0]);
                exit(1);
        }

        // Declare main functions scoped variables
        int status;

        // Parse args and ensure a valid process PID is passed.
        if (!(argc < 2)) {
                switch (argc - 1) {
                case 2: {
                        if (strcmp(argv[2], "--verbose") == 0)
                                gVerbose = true;
                        else
                                gVerbose = false;
                } break;
                default: break;
                }
        }

        // Convert argv[1] (<PID>: stdout of `$ pgrep lua`) to pid_t i.e. alias of integer.
        gProcPID = (pid_t)(atoi(argv[1]));
        if (!(gProcPID >= 0)) { // If is invalid (not a number or integer.) then
                fprintf(stderr, "Usage: %s <PID>\n", argv[0]);
                fprintf(stderr, "expected valid PID. For example: 105815\n. got: %i", gProcPID);
                status = 1;
                goto cleanupError; // Bail out on invalid pid
        }

        // Write stdout program name and version
        fprintf(stdout, "%s %s\n", MEMHOLD_ID, MEMHOLD_VERSION);
        if (gVerbose) {
                fprintf(stdout, "\n[ INFO ]  <<< Stage 1: Initialize program >>>\n\n");
                fprintf(stdout, "[ INFO ]  ");
                for (int i = 0; i < argc; i++)
                        fprintf(stdout, "%s ", argv[i]);
                fprintf(stdout, "\n");
                fprintf(stdout, "[ INFO ]  Verbose: %s\n", gVerbose ? "true" : "false");
        }

        // Initialize module
        status = Init();
        if (status != 0) {
                fprintf(stderr, "[ ERR! ]  failed to initialize module\n");
                goto cleanupError;
        }

        // Begin memhold hot loop.
        status = RunMain();

cleanupError:
        return status; // EXIT_SUCCESS
}
