#+title: Archives of memhold
#+author: Lloyd Lobo

* Significant Version Changes

** ver 0.1.0

*** 20240708102610UTC

**** memhold.c

#+begin_src c
  /*file: main.c*************************************************************************************
   *
   *
   *  memhold 0.1
   *
   *
   *  20240704144247UTC
   *      ==48754== Command: ./memhold 2007
   *      [ INFO ]  took 8.00s
   *      ==48754== HEAP SUMMARY:
   *      ==48754==     in use at exit: 0 bytes in 0 blocks
   *      ==48754==   total heap usage: 9 allocs, 9 frees, 7,008 bytes allocated
   *      ==48754== All heap blocks were freed -- no leaks are possible
   *      ==48754== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
   *
   *      ==46954== Command: ./memhold 2007
   *      [ INFO ]  took 8.00s
   *      ==46954== I refs:        285,880
   *
   *
   *************************************************************************************************/
  
  #include "memhold.h" // Declares module functions
  
  
  #include <assert.h> // Required for: assert()
  #include <signal.h>
  #include <stdio.h>  // Required for: printf(), fprintf(), sprintf(), stderr, stdout, popen() [with compiler option `-pthread`]
  #include <stdlib.h> // Required for: atoi(), exit()
  #include <string.h> // Required for: strcmp(), NULL
  #include <sys/wait.h>
  #include <time.h>   // Required for: clock(), [time() ~ not used]
  #include <unistd.h> // Required for: fork(), getpid(), sleep(),... [UNIX only lib]
  
  
  //-----------------------------------------------------------------------------
  // Debug Flags (set in build step)
  //-----------------------------------------------------------------------------
  
  // Debugging: ~ + MEMHOLD_SLOW = 0 --> fast code + MEMHOLD_SLOW = 1 --> slow code: See in "./Makefile": ~ + DFLAGS = -DMEMHOLD_SLOW=0
  #if defined(MEMHOLD_SLOW)
      #define MEMHOLD_SLOW = 0
  
  #endif
  
  // For when we want to enjoy dabbling with xy problems, code golfing, busy work, and procrastination.
  #if defined(MEMHOLD_YAGNI)
      #define MEMHOLD_YAGNI = 0
  
  #endif
  
  
  //-----------------------------------------------------------------------------
  // Macros and Defines
  //-----------------------------------------------------------------------------
  
  // clang-format off
  #define COLOR_INFO    CLITERAL(Color) { 102, 191, 255, 255 }   // Sky Blue
  #define COLOR_WARN    CLITERAL(Color) { 255, 161, 0, 255 }     // Orange
  #define COLOR_ERROR   CLITERAL(Color) { 230, 41, 55, 255 }     // Red
  #define COLOR_SUCCESS CLITERAL(Color) { 0, 228, 48, 255 }      // Green
  // clang-format on
  
  
  //-----------------------------------------------------------------------------
  // Some constants
  //-----------------------------------------------------------------------------
  
  // 2s refresh cycle per loop
  static const int MAX_HOT_LOOP_COUNT = (1 << 8); //> `256 (0x100)` (1 << 8)
  
  // Limit fopen for file at path: `char path[256]; snprintf(path, sizeof(path), "/proc/%d/status", pid);`
  static const int MAX_RETRIES_FILE_NOT_FOUND = (1 << 3); //> `8 (0x100)` (1 << 3)
  
  
  //-----------------------------------------------------------------------------
  // DATA STRUCTURESSSSS
  //-----------------------------------------------------------------------------
  
  typedef struct Memhold
  {
      bool flagLog;
      bool flagVerbose;
  
      const char *apiID;
      char       *apiVersion;
  
      float refreshSeconds;
  
      float  cpuThreshold;
      size_t memThreshold;
  
      pid_t userProcessPID;
      pid_t memholdMainProcessPID;
  
  } Memhold;
  
  //-----------------------------------------------------------------------------
  // Global variables
  //-----------------------------------------------------------------------------
  // TODO: All declared global variables, must be initialized. Even if it is 0 again.
  
  Memhold memhold = {0};
  
  bool  gVerbose; //@Temp
  pid_t gProcPID;
  
  static int cntrFopenRetries = 0;
  
  //-----------------------------------------------------------------------------
  // FUNCTIONSSSS
  //-----------------------------------------------------------------------------
  
  MHAPI Memhold InitMemhold(void);
  
  MHAPI Memhold InitMemhold(void)
  {
      Memhold result = {};
  
      result = (Memhold){
          .flagLog     = true,     // TODO(Lloyd): Override via CLI args
          .flagVerbose = gVerbose, // TODO(Lloyd): Override via CLI args
  
          .apiID      = MEMHOLD_ID,
          .apiVersion = MEMHOLD_VERSION,
  
          .refreshSeconds = 2.0f,
  
          .cpuThreshold = 50.0f,
          .memThreshold = MH_MEMORY_THRESHOLD, //>10240kb Max: 500000kb
  
          .userProcessPID        = gProcPID,
          .memholdMainProcessPID = 0,
      };
  
      return result;
  }
  
  int Init(void);
  
  int Init(void)
  {
      int status = -1; // SUCCESS
  
      cntrFopenRetries = 0;
      memhold          = InitMemhold();
      {
          memhold.memholdMainProcessPID = getpid();
      }
      status = 0;
  
      return status;
  };
  
  /* 1.14. /proc
  
  Linux Filesystem Hierarchy:
  Chapter 1. Linux Filesystem Hierarchy
  See https://tldp.org/LDP/Linux-Filesystem-Hierarchy/html/proc.html
  
  The purpose and contents of each of these files is explained below:
  
  /proc/PID/cmdline   Command line arguments.
  /proc/PID/cpu       Current and last cpu in which it was executed.
  /proc/PID/cwd       Link to the current working directory.
  /proc/PID/environ   Values of environment variables.
  /proc/PID/exe       Link to the executable of this process.
  /proc/PID/fd        Directory, which contains all file descriptors.
  /proc/PID/maps      Memory maps to executables and library files.
  /proc/PID/mem       Memory held by this process.
  /proc/PID/root      Link to the root directory of this process.
  /proc/PID/stat      Process status.
  /proc/PID/statm     Process memory status information.
  /proc/PID/status    Process status in human readable form.
  
  Should you wish to know more, the man page for proc describes each of the files
  associated with a running process ID in far greater detail.
  Even though files appear to be of size 0, examining their contents reveals
  otherwise:
  # cat status
  ...
  
  Details of this process can be obtained by looking at the associated files in
  the directory for this process, /proc/460. You might wonder how you can see
  details of a process that has a file size of 0. It makes more sense if you think
  of it as a window into the kernel. The file doesn't actually contain any data;
  it just acts as a pointer to where the actual process information resides.
  ...
  
  */
  
  /*
   attr/
   cwd/
   fd/
   fdinfo/
   map_files/
   net/
   ns/
   root/
   task/
   arch_status
   autogroup
   auxv
   cgroup
   clear_refs
   cmdline
   comm
   coredump_filter
   cpuset
   environ
   exe@
   gid_map
   io
   ksm_merging_pages
   ksm_stat
   limits
   loginuid
   maps
   mem
   mountinfo
   mounts
   mountstats
   numa_maps
   oom_adj
   oom_score
  v
  1/54 H 2024-07-07 12:12 dr-xr-xr-x 0B
  */
  
  //-----------------------------------------------------------------------------
  // Module specific function declarations
  //-----------------------------------------------------------------------------
  
  int RunMain(void);
  
  MHAPI long GetCpuUsage(pid_t pid);
  MHAPI long GetMemUsage(pid_t pid);
  MHAPI long GetSystemUptimeSec(pid_t pid);
  
  MHAPI void LogProcLimits(pid_t pid);
  MHAPI void NoOp(void); // Placeholder function that does nothing.
  
  
  #if MEMHOLD_YAGNI
  MHAPI void PanicUnimplemented(void);
  #endif /* if MEMHOLD_YAGNI */
  
  
  //-----------------------------------------------------------------------------
  // Module specific function implementations
  //-----------------------------------------------------------------------------
  
  MHAPI void NoOp(void) {}
  
  
  // See also: ~
  //   - snprintf(path, sizeof(path), "/proc/%d/status", pid);
  //     /proc/[pid]/status:
  //       While primarily used for memory information, it does contain some CPU-related fields:
  //
  //       Threads: Number of threads in the process
  //       voluntary_ctxt_switches and nonvoluntary_ctxt_switches: Context switch counts
  //
  MHAPI void LogProcLimits(pid_t pid)
  {
      long status = -1;
  
      // /proc
      // NOTE: The file doesn't actually contain any data; it just acts as a
      // pointer to where the actual process information resides.
      // See https://tldp.org/LDP/Linux-Filesystem-Hierarchy/html/proc.html
      char path[256];
      snprintf(path, sizeof(path), "/proc/%d/limits", pid);  // Choices: cpuset
                                                             //
      fprintf(stdout, "[ INFO ]  PID: %d  %s\n", pid, path); //> path = /proc/2014/cpuset
  
      // The file doesn't actually contain any data; it just acts as a pointer to
      // where the actual process information resides.
      FILE *fp = fopen(path, "r"); //> stream or NULL
  
      if (!fp)
      {
          fprintf(stderr, "[ ERR! ]  failed to open status file. file: %p\n", fp);
          status = -1;
          goto ioError;
      }
  
      char line[356];
      int  lineCount = 0;
  
      while (fgets(line, sizeof(line), fp))
      {
          if (memhold.flagVerbose)
          {
              lineCount += 1;
              fprintf(stdout, "[ INFO ]  PID: %d  \t| %2d ~ %s", pid, lineCount, line);
          }
      }
  
      status = fclose(fp);
  
      if ((status != 0))
      {
          perror("[ !ERR ]  failed to close status file");
          goto ioError;
      }
  
      return;
  
  ioError:
  
      return;
  }
  
  
  MHAPI long GetSystemUptimeSec(pid_t pid)
  {
      long status = -1;
  
      long systemUptime = -1;
  
      /*
      $ cat /proc/uptime
      6644.50 23980.38
      $ tr . ' ' </proc/uptime | awk '{print $1}'
      6667
      */
  
      FILE *fp = fopen("/proc/uptime", "r");
  
      if (!fp)
      {
          fprintf(stderr, "[ ERR! ]  failed to open status file. file: %p\n", fp);
          status = -1;
          goto ioError; // Bail out when file pointer fails to open
      }
  
      char line[356];
      int  lineCount = 0;
  
      // while (fgets(line, sizeof(line), fp))
      // {
      //     printf("line = %s\n", line);
      // }
  
  
      long tmpfieldNext = -1;
  
      fscanf(fp, "%lu %lu", &systemUptime, &tmpfieldNext);
      fclose(fp);
  
  
  
      return systemUptime;
  
  ioError:
  
      return status;
  }
  
  
  // /proc/[pid]/stat:
  // This file contains more detailed CPU usage data. The relevant fields are: ~
  //   - utime: User mode CPU time
  //   - stime: Kernel mode CPU time
  //
  // Note: ~
  //   - For processes using popen use: ~ "ps -p %d -o %%cpu --no-headers"
  MHAPI long GetCpuUsage(pid_t pid)
  {
  
      long status = -1;
      //
      char path[256];
      snprintf(path, sizeof(path), "/proc/%d/stat", pid); // "/proc/%d/stat" is
  
      // The file doesn't actually contain any data; it just acts as a pointer to
      // where the actual process information resides.
      FILE *fp = fopen(path, "r"); //> stream or NULL
  
      if (!fp)
      {
          fprintf(stderr, "[ ERR! ]  failed to open status file. file: %p\n", fp);
          status = -1;
          goto ioError; // Bail out
      }
  
  
      const long CLOCK_TICKS = sysconf(_SC_CLK_TCK); // Repeated again. it's okay ^_^
  
      long                   cpuUsage         = -1; // Result
      unsigned long long int processUtime     = 0;
      unsigned long long int processStime     = 0;
      long long              processStarttime = 0;
  
      char line[356];
      int  lineCount = 0;
  
  
  #if 0
     // Skip the first 13 fields
      for (int i = 0; i < 13; i++) {
          fscanf(file, "%*s");
      }
  
      fscanf(file, "%llu %llu", &utime, &stime);
      fclose(file);
  #endif /* if 0 */
  
  
      // Split fields in output of /proc/<pid>/stat that are presented as a series
      // of numbers and values separated by spaces.
      //----------------------------------------------------------------------------------
      const int MAX_TOKENS_CONSUMED_COUNT = 30; // Prevent infinite loops in inner while loop
  
      while (fgets(line, sizeof(line), fp))
      {
          char *token = strtok(line, " "); // Divide S into tokens separated by characters in DELIM.
  
  #if MEMHOLD_YAGNI
          char *token = strchr(line, ' ');
  #endif
  
          int tokenConsumedCount = 1;
  
          while (token != NULL)
          {
              if (tokenConsumedCount >= MAX_TOKENS_CONSUMED_COUNT) break;
  
              // Assign tokens
              // See https://github.com/htop-dev/htop/blob/db73229bddc6efd26875213f7927b156feb5a937/linux/LinuxProcessTable.c#L276
  
              /* (14) utime  -  %lu */
              if (tokenConsumedCount == PROCESS_STAT_UTIME_INDEX) processUtime = strtoull(token, NULL, 10);
  
              /* (15) stime  -  %lu */
              if (tokenConsumedCount == PROCESS_STAT_STIME_INDEX) processStime = strtoull(token, NULL, 10);
  
              /* (22) starttime  -  %llu */
              if (tokenConsumedCount == PROCESS_STAT_STARTTIME_INDEX)
              { // TODO(Lloyd): Adjust for boottime + adjustTime(lhost, ...)  / 100; See
                // https://github.com/htop-dev/htop/blob/db73229bddc6efd26875213f7927b156feb5a937/linux/LinuxProcessTable.c#L381
                  if (processStarttime == 0) processStarttime = (strtoll(token, NULL, 10) / CLOCK_TICKS);
              }
  
              // Consume token
              token = strtok(NULL, " ");
              tokenConsumedCount += 1;
          }
      }
  
      if (processUtime && processStime)
      {
          // getconf
  
          cpuUsage = (processUtime + processStime);
      }
  
      assert((cpuUsage != -1) && "expected valid cpu usage while reading /proc/<pid>/stat");
      //----------------------------------------------------------------------------------
  
      status = fclose(fp); // Cleanup
  
      if ((status != 0))
      {
          perror("[ !ERR ]  failed to close status file");
          goto ioError; // Bail out when close error
      }
  
      if (0) fprintf(stdout, "[ INFO ]  PID: %d  starttime: %llu\n", pid, processStarttime);
  
      return cpuUsage;
  
  ioError:
  
      return status;
  };
  
  
  // For processes using popen use: ~ "ps -p %d -o rss --no-headers"
  MHAPI long GetMemUsage(pid_t pid)
  {
      long status = -1;
  
      char path[256];
      snprintf(path, sizeof(path), "/proc/%d/status", pid); // Choices: status, mem
  
      // The file doesn't actually contain any data; it just acts as a pointer to
      // where the actual process information resides.
      FILE *fp = fopen(path, "r"); //> stream or NULL
  
      if (!fp) // [ ERR! ]  failed to open status file. file: (nil)
      {        // zsh: segmentation fault (core dumped)  ./memhold $(pgrep clang)
          fprintf(stderr, "[ ERR! ]  failed to open status file. file: %p\n", fp);
          status = -1;
          goto ioError; // Bail out
      }
  
  
      char line[356];
      long memoryUsage = -1;
  
      /*
      VmRSS stands for Virtual Memory Resident Set Size.
  
      VmRSS shows the amount of physical memory (RAM) that a process is
      currently using. This includes:
  
        - The process's code
        - Its data
        - Shared libraries that are currently loaded into RAM
      */
      while (fgets(line, sizeof(line), fp))
      {
          if (strncmp(line, "VmRSS:", 6) == 0)
          {
              sscanf(line + 6, "%ld", &memoryUsage);
              status = 0; // Success
              break;
          }
      }
  
      status = fclose(fp); // Cleanup
  
      if (status != 0)
      {
          perror("[ ERR! ]  failed to close status file");
          goto ioError;
      }
  
      return memoryUsage;
  
  ioError:
  
      return status;
  };
  
  #if MEMHOLD_YAGNI
  MHAPI void PanicUnimplemented(void) { UNIMPLEMENTED; }
  #endif /* if MEMHOLD_YAGNI */
  
  //-----------------------------------------------------------------------------
  // IT'S SHOWTIME                                                       ^_^
  //-----------------------------------------------------------------------------
  
  int RunMain(void)
  {
      int status = 0; // EXIT_SUCCESS
  
      // Log module information to stdout
      //----------------------------------------------------------------------------------
      if (memhold.flagVerbose)
      {
          fprintf(stdout, "[  OK  ]  <PID> %d\n", memhold.userProcessPID);
          LogProcLimits(memhold.userProcessPID);
      }
  
      if (memhold.flagLog)
      {
          // Log user stats
          fprintf(stdout, "[ INFO ]  [ user ]\n");
          fprintf(stdout, "[ INFO ]  PID: %d\n", memhold.userProcessPID);
          // Opts: constants like
          fprintf(stdout, "[ INFO ]  Threshold CPU: %f\n", memhold.cpuThreshold);
          fprintf(stdout, "[ INFO ]  Threshold MEM: %zu\n", memhold.memThreshold);
          // Opts: loop stats
          fprintf(stdout, "[ INFO ]  Refresh: %.2fs (%s)\n", memhold.refreshSeconds, memhold.apiID);
  
          // Log memhold stats
          fprintf(stdout, "[ INFO ]  [ %s ]\n", memhold.apiID);
          fprintf(stdout, "[ INFO ]  PID: %d\n", memhold.memholdMainProcessPID);
          // Memhold: stats
          fprintf(stdout, "[ INFO ]  Version: %d.%d.%d\n", MEMHOLD_VERSION_MAJOR, MEMHOLD_VERSION_MINOR, MEMHOLD_VERSION_PATCH);
      }
      //----------------------------------------------------------------------------------
  
      // Prepare main loop
      //----------------------------------------------------------------------------------
      if (memhold.flagVerbose) fprintf(stdout, "\n[ INFO ]  <<< Stage 2: Monitor processes >>>\n\n");
  
      char cmdGetProcName[256];
  
      char   cmdCPU[256];
      char   cmdMEM[256];
      size_t cpuUsage[64];
      size_t memUsage[64];
  
      int    cpuUsageCounter   = 0;
      int    memUsageCounter   = 0;
      size_t cpuUsageThisFrame = 0;
      size_t memUsageThisFrame = 0;
  
  #if 0 && MEMHOLD_YAGNI
      //
      // Prepare command statements
      //
  
      int stackAllocCmd = (sizeof(cmdCPU) + sizeof(cmdMEM) + sizeof(cmdGetProcName)); //> 768
      int bytesSoFar    = 0;
  
      bytesSoFar += snprintf(cmdCPU, sizeof(cmdCPU), "ps -p %d -o %%cpu --no-headers", memhold.userProcessPID);
      bytesSoFar += snprintf(cmdMEM, sizeof(cmdMEM), "ps -p %d -o rss --no-headers", memhold.userProcessPID);
      bytesSoFar += snprintf(cmdGetProcName, sizeof(cmdGetProcName), "ps aux | grep %d", memhold.userProcessPID);
      assert(bytesSoFar >= 64 && bytesSoFar <= stackAllocCmd); //> 79 >= 64
  
      #if 0            // TEMP LOG to stdout Process Name
          int ret = system(cmdGetProcName);
          if (ret != 0) {
              char msg[256];
              snprintf(msg, sizeof(msg), "[ ERR! ]  failed to execute command. system call returned: %d", ret);
              perror(msg);
              exit(1);
          };
      #endif           /* if 0 */
  
      const int CMD_MAX = 1035;
      int       pstatus;
      FILE     *pipefp;
      char      cmd[CMD_MAX];
      pipefp = popen(cmdGetProcName, "r");
      if (pipefp == NULL) {
          perror("[ ERR! ]  failed to execute popen for getting process name via its PID");
          exit(1);
      }
  
      int cntr = 0;
      while (fgets(cmd, CMD_MAX, pipefp) != NULL) {
          cntr++;
          fprintf(stdout, "[  OK  ] [%d]: %s", cntr, cmd);
      }
  
      pstatus = pclose(pipefp);
      if (pstatus == -1) perror("[ ERR! ] pclose"); // todo
      #if MEMHOLD_SLOW // TODO: use macros (From examples in popen() are marvelous articles?)
      else fprintf(stdout, "[ INFO ] pclose returned status for: %s\n", cmdGetProcName);
      #endif           /* if MEMHOLD_SLOW */
  
  #endif /* if MEMHOLD_YAGNI */
         //----------------------------------------------------------------------------------
  
      // Run main loop
      //----------------------------------------------------------------------------------
      const long         CLOCK_TICKS = sysconf(_SC_CLK_TCK); // $ getconf CLK_TCK #> 100 # 100 clock ticks in a second.
      int                loopCounter = 0;
      double             cpuPercent  = 0;
      unsigned long long cpuTime1, cpuTime2;
      unsigned int       cpuWaitASecond = 1;
  
  
      while (1)
      {
  
  #if 1 /* <<<<<<<<<<< Remove this after prototyping >>>>>>>>>> */
  
          if (loopCounter >= MAX_HOT_LOOP_COUNT)
          {
              fprintf(stdout, "[ WARN ]  *break* main loop on iteration: %d\n", loopCounter);
              break;
          };
  
          loopCounter += 1;
  
  #endif
  
          memUsageThisFrame = GetMemUsage(memhold.userProcessPID);
  
          // Pause this frame (2s per frame by default.)
          //----------------------------------------------------------------------------------
          { // Wait for 1 second
              cpuTime1 = GetCpuUsage(memhold.userProcessPID);
              sleep(cpuWaitASecond);
              cpuTime2 = GetCpuUsage(memhold.userProcessPID);
          }
          long systemUptime = GetSystemUptimeSec(memhold.userProcessPID);
          if (0) printf("systemUptime = %ld\r", systemUptime);
  
          // Calculate CPU usage
          // We use sysconf(_SC_CLK_TCK) to get the number of clock ticks per second, which allows us to convert from clock ticks to seconds.
          // @sysconf: Get the value of the system variable NAME. _SC_CLK_TCK:
          cpuPercent = (1.0 * (cpuTime2 - cpuTime1)) / CLOCK_TICKS; // Multiply by 1.0 to avoid precision loss while dividing in next instruction
  
  #if 0  // Disabled as the value is too small and seems to be double of CPU% in btop for the running user process.
          cpuPercent /= 100.0;
  #endif /* if 0 */
  
          // Ensure the loop waited for total `memhold.refreshSeconds` seconds
          if (cpuWaitASecond < memhold.refreshSeconds) { sleep(memhold.refreshSeconds - cpuWaitASecond); }
          //----------------------------------------------------------------------------------
  
          if (memhold.flagVerbose)
          {
              if (0) { fprintf(stdout, "[ INFO ]  PID: %d  CPU: %3.6f%%  \t%ld\n", memhold.userProcessPID, cpuPercent, clock()); }
  
              fprintf(stdout, "[ INFO ]  PID: %d  MEM: %8zuK  \t%ld\r", memhold.userProcessPID, memUsageThisFrame, clock());
              fflush(stdout);
          }
      }
      // end while (1)
      //----------------------------------------------------------------------------------
  
      // Unload program
      //----------------------------------------------------------------------------------
      // NOTE(Lloyd): Unload more data or free memory here... (e.g. ML_FREE(...))
      // ...
  
      if (memhold.flagVerbose)
      {
          fprintf(stdout, "\n[ INFO ]  <<< Stage 3: Cleanup and Exit >>>\n\n");
          fprintf(stdout, "[ INFO ]  took %.2fs\n", loopCounter * memhold.refreshSeconds);
      }
      //----------------------------------------------------------------------------------
  
      return status;
  };
  
  // Main entry point of the program.
  int main(int argc, char *argv[])
  {
      if (argc < 2)
      {
          fprintf(stderr, "Usage: %s <PID>\n", argv[0]);
          exit(1);
      }
  
  
      // Declare main functions scoped variables
      //----------------------------------------------------------------------------------
      int status;
      //----------------------------------------------------------------------------------
  
  
      // Parse args and ensure a valid process PID is passed.
      //----------------------------------------------------------------------------------
      if (!(argc < 2))
      {
          switch (argc - 1)
          {
  
          case 2:
              if (strcmp(argv[2], "--verbose") == 0) { gVerbose = true; }
              else gVerbose = false;
              break;
  
          default: break;
          }
      }
  
      // Convert argv[1] (<PID>: stdout of `$ pgrep lua`) to pid_t i.e. alias of integer.
      gProcPID = (pid_t)(atoi(argv[1]));
  
      // <<<<<<< HOW TO FIGURE OUT WHAT A VALID PID IS???? >>>>>>
      // If is invalid (not a number or integer.) then
      if (!(gProcPID >= 0))
      {
          fprintf(stderr, "Usage: %s <PID>\n", argv[0]);
          fprintf(stderr, "expected valid PID. For example: 105815\n. got: %i", gProcPID);
          status = 1;
          goto cleanupError; // Bail out on invalid pid
      }
      //----------------------------------------------------------------------------------
  
  
      // Write stdout program name and version
      //----------------------------------------------------------------------------------
      fprintf(stdout, "%s %s\n", MEMHOLD_ID, MEMHOLD_VERSION);
  
      if (gVerbose)
      {
          fprintf(stdout, "\n[ INFO ]  <<< Stage 1: Initialize program >>>\n\n");
          {
              fprintf(stdout, "[ INFO ]  ");
              for (int i = 0; i < argc; i++)
                  fprintf(stdout, "%s ", argv[i]);
              fprintf(stdout, "\n");
          }
          fprintf(stdout, "[ INFO ]  Verbose: %s\n", gVerbose ? "true" : "false");
      }
      //----------------------------------------------------------------------------------
  
  
      // Initialize module
      //----------------------------------------------------------------------------------
      status = Init();
  
      if (status != 0)
      {
          fprintf(stderr, "[ ERR! ]  failed to initialize module\n");
  
          goto cleanupError;
      }
      //----------------------------------------------------------------------------------
  
      // Begin memhold hot loop.
      //----------------------------------------------------------------------------------
      status = RunMain();
      //----------------------------------------------------------------------------------
  
  cleanupError:
  
      return status; // EXIT_SUCCESS
  }
#+end_src

*** 20240704140047UTC 

**** memhold.c

#+begin_src c :tangle memhold_0_1_0.c
  // file: main.c
  #include "memhold.h" // Declares module functions
  #include <assert.h> // Required for: assert()
  #include <stdio.h>  // Required for: printf(), fprintf(), sprintf(), stderr, stdout
  #include <stdlib.h> // Required for: atoi(), exit()
  #include <string.h> // Required for: strcmp(), NULL
  #include <sys/wait.h>
  #include <unistd.h> // Required for: fork(), getpid(), sleep(),... [UNIX only lib]
  #if defined(MEMHOLD_SLOW)
      #define MEMHOLD_SLOW = 0
  #endif
  #if defined(MEMHOLD_YAGNI)
      #define MEMHOLD_YAGNI = 0
  #endif
  // clang-format off
  #define COLOR_INFO    CLITERAL(Color) { 102, 191, 255, 255 }   // Sky Blue
  #define COLOR_WARN    CLITERAL(Color) { 255, 161, 0, 255 }     // Orange
  #define COLOR_ERROR   CLITERAL(Color) { 230, 41, 55, 255 }     // Red
  #define COLOR_SUCCESS CLITERAL(Color) { 0, 228, 48, 255 }      // Green
  // clang-format on
  typedef __pid_t MH_PID_TYPE;
  typedef struct Memhold
  {
      bool flagLog;
      bool flagVerbose;
      const char *apiID;
      char       *apiVersion;
      float refreshSeconds;
      float  cpuThreshold;
      size_t memThreshold;
      __pid_t userProcessPID;
      __pid_t memholdMainProcessPID;
  } Memhold;
  //-----------------------------------------------------------------------------
  // Global variables
  //-----------------------------------------------------------------------------
  Memhold     memhold = {0};
  MH_PID_TYPE procPID;
  bool        tmpArgVerbose = true; // NOTE(Lloyd): Set this later to `memhold.flagVerbose`
  //------------------------------------------------------------------------
  // FUNCTIONSSSS
  //------------------------------------------------------------------------
  MHAPI Memhold InitMemhold(void);
  MHAPI Memhold InitMemhold(void)
  {
      Memhold result = {};
      result = (Memhold){
          .flagLog     = true, // TODO(Lloyd): Override via CLI args
          .flagVerbose = true, // TODO(Lloyd): Override via CLI args
          .apiID      = "memhold",
          .apiVersion = MEMHOLD_VERSION,
          .refreshSeconds = 2.0f,
          .cpuThreshold = 50.0f,
          .memThreshold = MH_MEMORY_THRESHOLD, //>10240kb Max: 500000kb
          .userProcessPID        = 0,
          .memholdMainProcessPID = 0,
      };
      return result;
  }
  MHAPI double GetCpuUsage(MH_PID_TYPE pid);
  MHAPI long   GetMemUsage(MH_PID_TYPE pid);
  int RunMain()
  {
      int success = 0; // EXIT_SUCCESS
      // Initialize module
      //-------------------------------------------------------------------------
      memhold                       = InitMemhold();
      memhold.userProcessPID        = procPID;
      memhold.memholdMainProcessPID = getpid();
      //-------------------------------------------------------------------------
      // Log module information to stdout
      //-------------------------------------------------------------------------
      if (memhold.flagVerbose) fprintf(stdout, "[  OK  ]  <PID> %d\n", memhold.userProcessPID);
      if (memhold.flagLog)
      {
          { // Log user stats
              fprintf(stdout, "[ INFO ]  [ user ]\n");
              fprintf(stdout, "[ INFO ]  PID: %d\n", memhold.userProcessPID);
              // Opts: constants like
              fprintf(stdout, "[ INFO ]  Threshold CPU: %f\n", memhold.cpuThreshold);
              fprintf(stdout, "[ INFO ]  Threshold MEM: %zu\n", memhold.memThreshold);
              // Opts: loop stats
              fprintf(stdout, "[ INFO ]  Refresh: %.2fs (%s)\n", memhold.refreshSeconds, memhold.apiID);
          }
          { // Log memhold stats
              fprintf(stdout, "[ INFO ]  [ %s ]\n", memhold.apiID);
              fprintf(stdout, "[ INFO ]  PID: %d\n", memhold.memholdMainProcessPID);
              // Memhold: stats
              fprintf(stdout, "[ INFO ]  Version: %d.%d.%d\n", MEMHOLD_VERSION_MAJOR, MEMHOLD_VERSION_MINOR, MEMHOLD_VERSION_PATCH);
          }
      }
      //-------------------------------------------------------------------------
  #if MEMHOLD_YAGNI
      __pid_t id = fork(); // Fork fun!!
      if (id == 0) printf("child process id = %d\n", id);
      else printf("not child process id = %d\n", id);
  #endif /* if MEMHOLD_YAGNI */
      // Start main loop
      //-------------------------------------------------------------------------
      int loopCounter = 0, maxLoopCount = 4;
  #if MEMHOLD_SLOW
      int sleepResultThisFrame = -1;
  #endif
      if (memhold.flagVerbose) fprintf(stdout, "\n[ INFO ]  <<< Stage 2: Monitor processes >>>\n\n");
      size_t cpuUsage[64];
      size_t memUsage[64];
      int    cpuUsageCounter   = 0;
      int    memUsageCounter   = 0;
      size_t cpuUsageThisFrame = 0;
      size_t memUsageThisFrame = 0;
      char   cmdCPU[256];
      char   cmdMEM[256];
      // Prepare command statements
      snprintf(cmdCPU, sizeof(cmdCPU), "ps -p %d -o %%cpu --no-headers", memhold.userProcessPID);
      snprintf(cmdMEM, sizeof(cmdMEM), "ps -p %d -o rss --no-headers", memhold.userProcessPID);
  #if MEMHOLD_YAGNI
      if (memhold.flagVerbose) fprintf(stdout, "[ INFO ]  %s[cpu]: Preparing command: $ %s\n", memhold.apiID, cmdCPU);
      if (memhold.flagVerbose) fprintf(stdout, "[ INFO ]  %s[mem]: Preparing command: $ %s\n", memhold.apiID, cmdMEM);
  #endif /* if MEMHOLD_YAGNI */
      // Run main loop
      while (1)
      {
          { // Get CPU Usage.
  #if MEMHOLD_YAGNI
              cpuUsageThisFrame         = 1.0f + loopCounter; // TEMPORARY PSEUDOCODE!!!!
              cpuUsage[cpuUsageCounter] = cpuUsageThisFrame;
              cpuUsageCounter += 1;
              cpuUsageCounter %= 64; // Avoid overflowing buffer!
  #endif                             /* if MEMHOLD_YAGNI */
              if (memhold.flagVerbose) fprintf(stdout, "[ INFO ]  cpu: %zu\n", cpuUsageThisFrame);
          }
          { // Get Memory Usage.
  #if MEMHOLD_YAGNI
              memUsageThisFrame         = 1.0f + loopCounter; // TEMPORARY PSEUDOCODE!!!!
              memUsage[memUsageCounter] = memUsageThisFrame;
              memUsageCounter += 1;
              memUsageCounter %= 64; // Avoid overflowing buffer!
  #endif                             /* if MEMHOLD_YAGNI */
              if (memhold.flagVerbose) fprintf(stdout, "[ INFO ]  mem: %zu\n", memUsageThisFrame);
  #if 0
              FILE *fp = popen(command, "r");
              if (!fp) { perror("popen"); exit(1); }
  #endif /* if 0 */
          }
          { // Sleep/Pause this frame.
  #if MEMHOLD_SLOW
              sleepResultThisFrame = sleep(memhold.refreshSeconds);
              assert(sleepResultThisFrame == 0 && "failed to assert 0 code from sleep signal result");
  #else
              sleep(memhold.refreshSeconds); // Default: 2s per frame
  #endif /* if MEMHOLD_SLOW */
          }
  #if 1 || MEMHOLD_SLOW
          // TODO(Lloyd): Remove the overide `1` after prototyping - 20240703114505UTC
          loopCounter += 1;
          if (loopCounter >= maxLoopCount)
          {
              fprintf(stdout, "[ WARN ]  *break* main loop on iteration: %d\n", loopCounter);
              break;
          };
  #endif /* if 1 || MEMHOLD_SLOW */
      } // end while (1)
      //-------------------------------------------------------------------------
      // Unload program
      //-------------------------------------------------------------------------
      if (memhold.flagVerbose)
      {
          fprintf(stdout, "\n[ INFO ]  <<< Stage 3: Cleanup and Exit >>>\n\n");
          fprintf(stdout, "[ INFO ]  took %.2fs\n", loopCounter * memhold.refreshSeconds);
      }
      // TODO(Lloyd): Unload more data or free memory here...
      // (e.g. ML_FREE(...))
      //-------------------------------------------------------------------------
      return success;
  };
  
  int main(int argc, char *argv[])
  {
      if (argc != 2)
      {
          fprintf(stderr, "Usage: %s <PID>\n", argv[0]);
          exit(1);
      }
      // Write stdout program name and version
      memhold.apiVersion = MEMHOLD_VERSION;
      fprintf(stdout, "memhold %s\n", memhold.apiVersion);
      if (tmpArgVerbose) fprintf(stdout, "\n[ INFO ]  <<< Stage 1: Initialize program >>>\n\n");
      // Parse args and ensure a valid process PID is passed.
      //-------------------------------------------------------------------------
      {                                       // $ pgrep waybar | xargs -I _ ./memhold _
          char *pid = argv[1];                // argv[1] is stdout of `$ pgrep lua`
          procPID   = (MH_PID_TYPE)atoi(pid); // This will panic either way.
  
          if (!(procPID >= 0)) // If not a number|integer...
          {
              fprintf(stderr, "Usage: %s <PID>\n", argv[0]);
              fprintf(stderr, "expected valid PID. For example: 105815\n. got: %i", procPID);
              exit(1);
          }
      }
      //-------------------------------------------------------------------------
      int success = RunMain();
      return success; // EXIT_SUCCESS
  }
#+end_src

** ver 0.0.9

*** 20240703132234UTC

**** memhold.c

#+begin_src c :tangle memhold_0_0_9.c
  #include "memhold.h" // Declares module functions
  #include <assert.h> // Required for: assert(),
  #include <stdio.h>  // Required for: printf(), fprintf(), sprintf(), stderr, stdout,
  #include <stdlib.h> // Required for: atoi(), exit(),
  #include <string.h> // Required for: strcmp(),
  #include <sys/wait.h>
  #include <unistd.h> // Required for: fork(), getpid(), sleep(),... [UNIX only lib]

  #if defined(MEMHOLD_SLOW)
  #define MEMHOLD_SLOW = 0
  #endif

  #if defined(MEMHOLD_YAGNI)
  #define MEMHOLD_YAGNI = 0
  #endif

  // clang-format off
  #define COLOR_INFO    CLITERAL(Color) { 102, 191, 255, 255 }   // Sky Blue
  #define COLOR_WARN    CLITERAL(Color) { 255, 161, 0, 255 }     // Orange
  #define COLOR_ERROR   CLITERAL(Color) { 230, 41, 55, 255 }     // Red
  #define COLOR_SUCCESS CLITERAL(Color) { 0, 228, 48, 255 }      // Green
  // clang-format on

  // memhold.c:174:30: error: format specifies type 'char *' but the argument has
  // type '__pid_t' (aka 'int') [-Werror,-Wformat]
  //
  typedef __pid_t MH_PID_TYPE;

  typedef struct Memhold
  {
    bool flagLog;
    bool flagVerbose;

    const char *apiID;
    char       *apiVersion;

    float refreshSeconds;

    float  cpuThreshold;
    size_t memThreshold;

    __pid_t userProcessPID;
    __pid_t memholdMainProcessPID;

  } Memhold;

  MHAPI Memhold InitMemhold(void);
  MHAPI Memhold InitMemhold(void)
  {
    Memhold result = {};

    result = (Memhold){
      .flagLog     = true, // TODO(Lloyd): Override via CLI args
      .flagVerbose = true, // TODO(Lloyd): Override via CLI args

      .apiID      = "memhold",
      .apiVersion = MEMHOLD_VERSION,

      .refreshSeconds = 2.0f,

      .cpuThreshold = 50.0f,
      .memThreshold = MH_MEMORY_THRESHOLD, //>10240kb Max: 500000kb

      .userProcessPID        = 0,
      .memholdMainProcessPID = 0,
    };

    return result;
  }

  MHAPI double GetCpuUsage(MH_PID_TYPE pid);
  MHAPI long   GetMemUsage(MH_PID_TYPE pid);

  int main(int argc, char *argv[])
  {
    if (argc != 2)
      {
        fprintf(stderr, "Usage: %s <PID>\n", argv[0]);
        exit(1);
      }

    // Declare main function variables
    //-------------------------------------------------------------------------
    Memhold     memhold = {};
    MH_PID_TYPE procPID;
    // NOTE(Lloyd): Set this later to `memhold.flagVerbose`
    bool tmpArgVerbose = true;
    //------------------------------------------------------------------------

    // Write stdout program name and version
    memhold.apiVersion = MEMHOLD_VERSION;
    fprintf(stdout, "memhold %s\n", memhold.apiVersion);

    if (tmpArgVerbose) fprintf(stdout, "\n[ INFO ]  <<< Stage 1: Initialize program >>>\n\n");

    // Parse args and ensure a valid process PID is passed.
    //-------------------------------------------------------------------------
    {                                       // $ pgrep waybar | xargs -I _ ./memhold _
      char *pid = argv[1];                // argv[1] is stdout of `$ pgrep lua`
      procPID   = (MH_PID_TYPE)atoi(pid); // This will panic either way.

      if (!(procPID >= 0)) // If not a number|integer...
        {
  	fprintf(stderr, "Usage: %s <PID>\n", argv[0]);
  	fprintf(stderr, "expected valid PID. For example: 105815\n. got: %i", procPID);
  	exit(1);
        }
    }
    //-------------------------------------------------------------------------

    // Initialize module
    //-------------------------------------------------------------------------
    memhold                       = InitMemhold();
    memhold.userProcessPID        = procPID;
    memhold.memholdMainProcessPID = getpid();
    //-------------------------------------------------------------------------

    // Log module information to stdout
    //-------------------------------------------------------------------------
    if (memhold.flagVerbose) fprintf(stdout, "[  OK  ]  <PID> %d\n", memhold.userProcessPID);
    if (memhold.flagLog)
      {
        { // Log user stats
  	fprintf(stdout, "[ INFO ]  [ user ]\n");
  	fprintf(stdout, "[ INFO ]  PID: %d\n", memhold.userProcessPID);

  	// Opts: constants like
  	fprintf(stdout, "[ INFO ]  Threshold CPU: %f\n", memhold.cpuThreshold);
  	fprintf(stdout, "[ INFO ]  Threshold MEM: %zu\n", memhold.memThreshold);

  	// Opts: loop stats
  	fprintf(stdout, "[ INFO ]  Refresh: %.2fs (%s)\n", memhold.refreshSeconds, memhold.apiID);
        }

        { // Log memhold stats
  	fprintf(stdout, "[ INFO ]  [ %s ]\n", memhold.apiID);
  	fprintf(stdout, "[ INFO ]  PID: %d\n", memhold.memholdMainProcessPID);

  	// Memhold: stats
  	fprintf(stdout, "[ INFO ]  Version: %d.%d.%d\n", MEMHOLD_VERSION_MAJOR, MEMHOLD_VERSION_MINOR, MEMHOLD_VERSION_PATCH);
        }
      }
    //-------------------------------------------------------------------------

  #if MEMHOLD_YAGNI
    __pid_t id = fork(); // Fork fun!!

    if (id == 0) printf("child process id = %d\n", id);
    else printf("not child process id = %d\n", id);
  #endif /* if MEMHOLD_YAGNI */

    // Start main loop
    //-------------------------------------------------------------------------
    int loopCounter = 0, maxLoopCount = 4;

  #if MEMHOLD_SLOW
    int sleepResultThisFrame = -1;
  #endif

    if (memhold.flagVerbose) fprintf(stdout, "\n[ INFO ]  <<< Stage 2: Monitor processes >>>\n\n");

    size_t cpuUsage[64];
    size_t memUsage[64];
    int    cpuUsageCounter   = 0;
    int    memUsageCounter   = 0;
    size_t cpuUsageThisFrame = 0;
    size_t memUsageThisFrame = 0;
    char   cmdCPU[256];
    char   cmdMEM[256];

    // Prepare command statements
    snprintf(cmdCPU, sizeof(cmdCPU), "ps -p %d -o %%cpu --no-headers", memhold.userProcessPID);
    snprintf(cmdMEM, sizeof(cmdMEM), "ps -p %d -o rss --no-headers", memhold.userProcessPID);

  #if MEMHOLD_YAGNI
    if (memhold.flagVerbose) fprintf(stdout, "[ INFO ]  %s[cpu]: Preparing command: $ %s\n", memhold.apiID, cmdCPU);
    if (memhold.flagVerbose) fprintf(stdout, "[ INFO ]  %s[mem]: Preparing command: $ %s\n", memhold.apiID, cmdMEM);
  #endif /* if MEMHOLD_YAGNI */

    //
    //
    //
    //
    //
    // Run main loop
    while (1)
      {
        { // Get CPU Usage.
  #if MEMHOLD_YAGNI
  	cpuUsageThisFrame         = 1.0f + loopCounter; // TEMPORARY PSEUDOCODE!!!!
  	cpuUsage[cpuUsageCounter] = cpuUsageThisFrame;
  	cpuUsageCounter += 1;
  	cpuUsageCounter %= 64; // Avoid overflowing buffer!
  #endif                             /* if MEMHOLD_YAGNI */

  	if (memhold.flagVerbose) fprintf(stdout, "[ INFO ]  cpu: %zu\n", cpuUsageThisFrame);
        }

        { // Get Memory Usage.
  #if MEMHOLD_YAGNI
  	memUsageThisFrame         = 1.0f + loopCounter; // TEMPORARY PSEUDOCODE!!!!
  	memUsage[memUsageCounter] = memUsageThisFrame;
  	memUsageCounter += 1;
  	memUsageCounter %= 64; // Avoid overflowing buffer!
  #endif                             /* if MEMHOLD_YAGNI */
  	if (memhold.flagVerbose) fprintf(stdout, "[ INFO ]  mem: %zu\n", memUsageThisFrame);
  #if 0
  	FILE *fp = popen(command, "r");
  	if (!fp) { perror("popen"); exit(1); }
  #endif /* if 0 */
        }

        { // Sleep/Pause this frame.
  #if MEMHOLD_SLOW
  	sleepResultThisFrame = sleep(memhold.refreshSeconds);

  	assert(sleepResultThisFrame == 0 && "failed to assert 0 code from sleep signal result");
  #else
  	sleep(memhold.refreshSeconds); // Default: 2s per frame
  #endif /* if MEMHOLD_SLOW */
        }

  #if 1 || MEMHOLD_SLOW
        // TODO(Lloyd): Remove the overide `1` after prototyping - 20240703114505UTC
        loopCounter += 1;

        if (loopCounter >= maxLoopCount)
  	{
  	  fprintf(stdout, "[ WARN ]  *break* main loop on iteration: %d\n", loopCounter);
  	  break;
  	};
  #endif /* if 1 || MEMHOLD_SLOW */

      } // end while (1)
        //
        //
        //
        //
        //
    //-------------------------------------------------------------------------

    // Unload program
    //-------------------------------------------------------------------------
    if (memhold.flagVerbose)
      {
        fprintf(stdout, "\n[ INFO ]  <<< Stage 3: Cleanup and Exit >>>\n\n");
        fprintf(stdout, "[ INFO ]  took %.2fs\n", loopCounter * memhold.refreshSeconds);
      }

    // TODO(Lloyd): Unload more data or free memory here...
    // (e.g. ML_FREE(...))
    // ...
    // ...
    //-------------------------------------------------------------------------

    return 0; // EXIT_SUCCESS
  }

  // BOT
#+end_src

**** memhold.h

#+begin_src c :tangle memhold.h
  #ifndef MEMHOLD_H
  #define MEMHOLD_H

  #include <stdarg.h> // Required for: va_list - Only used by TraceLogCallback

  //// NOTE(Lloyd): The following is ported from raylib.h

  #define MEMHOLD_VERSION_MAJOR 0
  #define MEMHOLD_VERSION_MINOR 1
  #define MEMHOLD_VERSION_PATCH 0
  #define MEMHOLD_VERSION       "0.1"

  // Function specifiers in case library is build/used as a shared library (Windows)
  // NOTE: Microsoft specifiers to tell compiler that symbols are imported/exported from a .dll
  #if defined(_WIN32)
  #if defined(BUILD_LIBTYPE_SHARED)
  #if defined(__TINYC__)
  #define __declspec(x) __attribute__((x))
  #endif
  #define MHAPI __declspec(dllexport) // We are building the library as a Win32 shared library (.dll)
  #elif defined(USE_LIBTYPE_SHARED)
  #define MHAPI __declspec(dllimport) // We are using the library as a Win32 shared library (.dll)
  #endif
  #endif

  #ifndef MHAPI
  #define MHAPI // Functions defined as 'extern' by default (implicit specifiers)
  #endif

  //----------------------------------------------------------------------------------
  // Some basic Defines
  //----------------------------------------------------------------------------------

  // Memory threshold in kilobytes (for example, 10 MB)
  #define MH_MEMORY_THRESHOLD 10240

  // NOTE(Lloyd): The following is ported from raylib.h

  // Allow custom memory allocators
  // NOTE: Require recompiling raylib sources
  #ifndef MH_MALLOC
  #define MH_MALLOC(sz) malloc(sz)
  #endif
  #ifndef MH_CALLOC
  #define MH_CALLOC(n, sz) calloc(n, sz)
  #endif
  #ifndef MH_REALLOC
  #define MH_REALLOC(ptr, sz) realloc(ptr, sz)
  #endif
  #ifndef MH_FREE
  #define MH_FREE(ptr) free(ptr)
  #endif

  // NOTE: MSVC C++ compiler does not support compound literals (C99 feature)
  // Plain structures in C++ (without constructors) can be initialized with { }
  // This is called aggregate initialization (C++11 feature)
  #if defined(__cplusplus)
  #define CLITERAL(type) type
  #else
  #define CLITERAL(type) (type)
  #endif

  // Some compilers (mostly macos clang) default to C++98,
  // where aggregate initialization can't be used
  // So, give a more clear error stating how to fix this
  #if !defined(_MSC_VER) && (defined(__cplusplus) && __cplusplus < 201103L)
  #error "C++11 or later is required. Add -std=c++11"
  #endif

  /*
  // NOTE: We set some defines with some data types declared by raylib
  // Other modules (raymath, rlgl) also require some of those types, so,
  // to be able to use those other modules as standalone (not depending on raylib)
  // this defines are very useful for internal check and avoid type (re)definitions
  #define RL_COLOR_TYPE
  #define RL_RECTANGLE_TYPE
  #define RL_VECTOR2_TYPE
  #define RL_VECTOR3_TYPE
  #define RL_VECTOR4_TYPE
  #define RL_QUATERNION_TYPE
  #define RL_MATRIX_TYPE
  ,*/

  //----------------------------------------------------------------------------------
  // Structures Definition
  //----------------------------------------------------------------------------------

  // Boolean type
  #if (defined(__STDC__) && __STDC_VERSION__ >= 199901L) || (defined(_MSC_VER) && _MSC_VER >= 1800)
  #include <stdbool.h>
  #elif !defined(__cplusplus) && !defined(bool)
  typedef enum bool
    {
      false = 0,
      true  = !false
    } bool;
  #define RL_BOOL_TYPE
  #endif

  // Color, 4 components, R8G8B8A8 (32bit)
  typedef struct Color
  {
    unsigned char r; // Color red value
    unsigned char g; // Color green value
    unsigned char b; // Color blue value
    unsigned char a; // Color alpha value
  } Color;

  //----------------------------------------------------------------------------------
  // Enumerators Definition
  //----------------------------------------------------------------------------------

  // System/Window config flags
  // NOTE: Every bit registers one state (use it with bit masks)
  // By default all flags are set to 0
  typedef enum
    {
      FLAG_VSYNC_HINT               = 0x00000040, // Set to try enabling V-Sync on GPU
      FLAG_FULLSCREEN_MODE          = 0x00000002, // Set to run program in fullscreen
      FLAG_WINDOW_RESIZABLE         = 0x00000004, // Set to allow resizable window
      FLAG_WINDOW_UNDECORATED       = 0x00000008, // Set to disable window decoration (frame and buttons)
      FLAG_WINDOW_HIDDEN            = 0x00000080, // Set to hide window
      FLAG_WINDOW_MINIMIZED         = 0x00000200, // Set to minimize window (iconify)
      FLAG_WINDOW_MAXIMIZED         = 0x00000400, // Set to maximize window (expanded to monitor)
      FLAG_WINDOW_UNFOCUSED         = 0x00000800, // Set to window non focused
      FLAG_WINDOW_TOPMOST           = 0x00001000, // Set to window always on top
      FLAG_WINDOW_ALWAYS_RUN        = 0x00000100, // Set to allow windows running while minimized
      FLAG_WINDOW_TRANSPARENT       = 0x00000010, // Set to allow transparent framebuffer
      FLAG_WINDOW_HIGHDPI           = 0x00002000, // Set to support HighDPI
      FLAG_WINDOW_MOUSE_PASSTHROUGH = 0x00004000, // Set to support mouse passthrough, only supported when FLAG_WINDOW_UNDECORATED
      FLAG_BORDERLESS_WINDOWED_MODE = 0x00008000, // Set to run program in borderless windowed mode
      FLAG_MSAA_4X_HINT             = 0x00000020, // Set to try enabling MSAA 4X
      FLAG_INTERLACED_HINT          = 0x00010000  // Set to try enabling interlaced video format (for V3D)
    } ConfigFlags;

  // Trace log level
  // NOTE: Organized by priority level
  typedef enum
    {
      LOG_ALL = 0, // Display all logs
      LOG_TRACE,   // Trace logging, intended for internal use only
      LOG_DEBUG,   // Debug logging, used for internal debugging, it should be disabled on release builds
      LOG_INFO,    // Info logging, used for program execution info
      LOG_WARNING, // Warning logging, used on recoverable failures
      LOG_ERROR,   // Error logging, used on unrecoverable failures
      LOG_FATAL,   // Fatal logging, used to abort program: exit(EXIT_FAILURE)
      LOG_NONE     // Disable logging
    } TraceLogLevel;

  // Callbacks to hook some internal functions
  // WARNING: These callbacks are intended for advance users
  typedef void (*TraceLogCallback)(int logLevel, const char *text, va_list args);       // Logging: Redirect trace log messages
  typedef unsigned char *(*LoadFileDataCallback)(const char *fileName, int *dataSize);  // FileIO: Load binary data
  typedef bool (*SaveFileDataCallback)(const char *fileName, void *data, int dataSize); // FileIO: Save binary data
  typedef char *(*LoadFileTextCallback)(const char *fileName);                          // FileIO: Load text data
  typedef bool (*SaveFileTextCallback)(const char *fileName, char *text);               // FileIO: Save text data

  //------------------------------------------------------------------------------------
  // Global Variables Definition
  //------------------------------------------------------------------------------------
  // It's lonely here...

  //------------------------------------------------------------------------------------
  // Window and Graphics Device Functions (Module: core)
  //------------------------------------------------------------------------------------

  #if defined(__cplusplus)
  extern "C"
  { // Prevents name mangling of functions
  #endif

    // Window-related functions
    MHAPI void InitWindow(int width, int height, const char *title); // Initialize window and OpenGL context
    MHAPI void CloseWindow(void);                                    // Close window and unload OpenGL context
    MHAPI bool WindowShouldClose(void);                              // Check if application should close (KEY_ESCAPE pressed or windows close icon clicked)
    //
    // Timing-related functions
    MHAPI void   SetTargetFPS(int fps); // Set target FPS (maximum)
    MHAPI float  GetFrameTime(void);    // Get time in seconds for last frame drawn (delta time)
    MHAPI double GetTime(void);         // Get elapsed time in seconds since InitWindow()
    MHAPI int    GetFPS(void);          // Get current FPS

    // Custom frame control functions
    // NOTE: Those functions are intended for advance users that want full control over the frame processing
    // By default EndDrawing() does this job: draws everything + SwapScreenBuffer() + manage frame timing + PollInputEvents()
    // To avoid that behaviour and control frame processes manually, enable in config.h: SUPPORT_CUSTOM_FRAME_CONTROL
    MHAPI void SwapScreenBuffer(void);   // Swap back buffer with front buffer (screen drawing)
    MHAPI void PollInputEvents(void);    // Register all input events
    MHAPI void WaitTime(double seconds); // Wait for some time (halt program execution)

    // Random values generation functions
    MHAPI void SetRandomSeed(unsigned int seed);                         // Set the seed for the random number generator
    MHAPI int  GetRandomValue(int min, int max);                         // Get a random value between min and max (both included)
    MHAPI int *LoadRandomSequence(unsigned int count, int min, int max); // Load random values sequence, no values repeated
    MHAPI void UnloadRandomSequence(int *sequence);                      // Unload random values sequence

    // Misc. functions
    MHAPI void TakeScreenshot(const char *fileName); // Takes a screenshot of current screen (filename extension defines format)
    MHAPI void SetConfigFlags(unsigned int flags);   // Setup init configuration flags (view FLAGS)
    MHAPI void OpenURL(const char *url);             // Open URL with default system browser (if available)

    // NOTE: Following functions implemented in module [utils]
    //------------------------------------------------------------------
    MHAPI void  TraceLog(int logLevel, const char *text, ...); // Show trace log messages (LOG_DEBUG, LOG_INFO, LOG_WARNING, LOG_ERROR...)
    MHAPI void  SetTraceLogLevel(int logLevel);                // Set the current threshold (minimum) log level
    MHAPI void *MemAlloc(unsigned int size);                   // Internal memory allocator
    MHAPI void *MemRealloc(void *ptr, unsigned int size);      // Internal memory reallocator
    MHAPI void  MemFree(void *ptr);                            // Internal memory free

    // Set custom callbacks
    // WARNING: Callbacks setup is intended for advance users
    MHAPI void SetTraceLogCallback(TraceLogCallback callback);         // Set custom trace log
    MHAPI void SetLoadFileDataCallback(LoadFileDataCallback callback); // Set custom file binary data loader
    MHAPI void SetSaveFileDataCallback(SaveFileDataCallback callback); // Set custom file binary data saver
    MHAPI void SetLoadFileTextCallback(LoadFileTextCallback callback); // Set custom file text data loader
    MHAPI void SetSaveFileTextCallback(SaveFileTextCallback callback); // Set custom file text data saver

    // Files management functions
    MHAPI unsigned char *LoadFileData(const char *fileName, int *dataSize);            // Load file data as byte array (read)
    MHAPI void           UnloadFileData(unsigned char *data);                          // Unload file data allocated by LoadFileData()
    MHAPI bool           SaveFileData(const char *fileName, void *data, int dataSize); // Save data to file from byte array (write), returns true on success
    MHAPI bool           ExportDataAsCode(const unsigned char *data, int dataSize, const char *fileName); // Export data to code (.h), returns true on success
    MHAPI char          *LoadFileText(const char *fileName);   // Load text data from file (read), returns a '\0' terminated string
    MHAPI void           UnloadFileText(char *text);           // Unload file text data allocated by LoadFileText()
    MHAPI bool SaveFileText(const char *fileName, char *text); // Save text data to file (write), string must be '\0' terminated, returns true on success
    //------------------------------------------------------------------

  #if defined(__cplusplus)
  }
  #endif

  #endif // !MEMHOLD_H
#+end_src

* See https://www.baeldung.com/linux/total-process-cpu-usage#1-the-procltpidgtstat-file

#+begin_quote
  2.1. The /proc/<pid>/stat File
  Inside the /proc directory, each process has its own /proc/<pid> folder, identified by the process’s PID. Then, each process has the special file /proc/<pid>/stat that contains the process’s status.
  
  The /proc/<pid>/stat file contains the information to calculate the total CPU usage. It’s a plain text file holding several values separated by whitespaces.
  
  Let’s use cat to see the status of the current shell. We can use the $$ special variable that is replaced with the current shell PID:
  
  $ cat /proc/$$/stat
  6608 (bash) S 2782 6608 6608 34818 25989 4194304 6423 130989 0 428 3 1 903 124 20 0 1 0 84265 9269248 1452 18446744073709551615 4345856 5123037 140728509762160 0 0 0 65536 3686404 1266761467 0 0 0 17 6 0 0 0 0 0 5362544 5410152 9601024 140728509767363 140728509767374 140728509767374 140728509771758 0
  
  We can see several values separated by whitespace, and each value has its meaning.
  
  For instance, the first value is the process ID, the second is the process’s name, and the third is the process’s state. We can see the full list of values and their meanings by running the man 5 proc command.
#+end_quote

*** 20240709234259UTC 

**** memhold.c

Testing typedef'd types for integers

#+begin_src c
    {
            i32 x = 1000000;                         // 32-bit signed integer
            i64 y = 1000000000000LL;                 // 64-bit signed integer (note the LL suffix)
            printf("x (32-bit) = %" PRId32 "\n", x); // Use the PRId32 and PRId64 macros (defined in <inttypes.h>) for portable printf format specifiers.
            printf("y (64-bit) = %" PRId64 "\n", y); // For unsigned versions, use uint32_t and uint64_t.


            unsigned long long ull  = 18446744073709551615ULL;
            u64                ui64 = 18446744073709551615ULL;
            printf("unsigned long long: %llu\n", ull); // The ULL suffix is used for unsigned long long literals.
            printf("uint64_t: %" PRIu64 "\n", ui64);   // Use the PRIu64 macro for the printf format specifier to ensure portability.
    }
#+end_src
